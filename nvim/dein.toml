[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'
hook_post_update = '''
  if dein#util#_is_windows()
    let cmd = 'tools\\update-dll-mingw'
  elseif dein#util#_is_cygwin()
    let cmd = 'make -f make_cygwin.mak'
  elseif executable('gmake')
    let cmd = 'gmake'
  else
    let cmd = 'make'
  endif
  let g:dein#plugin.build = cmd
'''

# View {{{
[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
  let g:lightline = {'colorscheme': 'solarized',
      \ 'mode_map': {'c': 'NORMAL'},
      \ 'active': {
          \ 'left': [['mode', 'paste'], ['fugitive', 'filename']]
      \ },
      \'component_function': {
          \ 'modified': 'MyModified',
          \ 'readonly': 'MyReadonly',
          \ 'fugitive': 'MyFugitive',
          \ 'filename': 'MyFilename',
          \ 'fileformat': 'MyFileformat',
          \ 'filetype': 'MyFiletype',
          \ 'fileencoding': 'MyFileencoding',
          \ 'mode': 'MyMode'
      \ }
  \}

  function! MyModified()
      return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  endfunction

  function! MyReadonly()
      return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  endfunction

  function! MyFilename()
    return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
          \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
          \  &ft == 'unite' ? unite#get_status_string() :
          \  &ft == 'vimshell' ? vimshell#get_status_string() :
          \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
          \ ('' != MyModified() ? ' ' . MyModified() : '')
  endfunction

  function! MyFugitive()
    try
      if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
        return fugitive#head()
      endif
    catch
    endtry
    return ''
  endfunction

  function! MyFileformat()
    return winwidth(0) > 70 ? &fileformat : ''
  endfunction

  function! MyFiletype()
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
  endfunction

  function! MyFileencoding()
    return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
  endfunction

  function! MyMode()
    return winwidth(0) > 60 ? lightline#mode() : ''
  endfunction
'''

[[plugins]]
repo = 'tomasr/molokai'
hook_add = '''
  let g:molokai_original = 1
  autocmd myautocmd VimEnter * colorscheme molokai "TODO: transpansy
'''
  #set background=dark
# }}} View


# Input {{{
#[[plugins]]
#repo = 'Shougo/neocomplete'
#hook_add = '''
#  let g:acp_enableAtStartup = 0
#  let g:neocomplete#enable_at_startup = 1
#  let g:neocomplete#max_list = 5
#  let g:neocomplete#auto_completion_start_length = 3
#  let g:neocomplete#enable_underbar_completion = 0
#  let g:NeoComplete#EnableAtStartup = 1
#'''

[[plugins]]
repo = 'Shougo/deoplete.nvim'
hook_add = '''
  let g:deoplete#enable_at_startup = 1
  let g:deoplete#max_list = 5
  let g:deoplete#auto_complete_start_length = 3
'''

[[plugins]]
repo = 'Shougo/neosnippet'
hook_add = '''
  imap <C-k>     <Plug>(neosnippet_expand_or_jump)
  smap <C-k>     <Plug>(neosnippet_expand_or_jump)
  xmap <C-k>     <Plug>(neosnippet_expand_target)

  " SuperTab like snippets behavior.
  imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \: pumvisible() ? "\<C-n>" : "\<TAB>"
  smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \: "\<TAB>"

  let g:neosnippet#enable_snipmate_compatibility = 1
  " for reloading directory
  let g:neosnippet#disable_runtime_snippets = {'_' : 1}
  let g:neosnippet#snippets_directory = ['~/.config/nvim/snippets']
  let g:neosnippet#snippets_directory+=[g:dein_dir . '/repos/github.com/Shougo/neosnippet-snippets/neosnippets']

  if has('conceal') " For snippet_complete marker.
    set conceallevel=2 concealcursor=i
  endif
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'
hook_add = '''
  let g:neosnippet#snippets_directory += [g:dein_dir . '/github.com/honza/vim-snippets/snippets']
'''

[[plugins]]
repo = 'honza/vim-snippets'

[[plugins]]
repo = 'tpope/vim-surround'
# }}} Input


# code check {{{
[[plugins]]
repo = 'cohama/vim-hier'

[[plugins]]
repo = 'osyo-manga/shabadou.vim'

[[plugins]]
repo = 'dannyob/quickfixstatus'

[[plugins]]
repo    = 'osyo-manga/vim-watchdogs'
depends = [
  'vim-hier',
  'quickfixstatus',
  'shabadou.vim',
  'vim-quickrun',
]
on_idle = 1
hook_add = '''
  let g:watchdogs_check_BufWritePost_enable = 1
  let g:watchdogs_check_CursorHold_enable = 1

  let g:quickrun_config = get(g:, 'quickrun_config', {})
  let g:quickrun_config['watchdogs_checker/jshint'] = {'cmdopt': '--config `/.jshintrc'}

  let s:pyflakes = executable('pyflakes3')? 'pyflakes3':
    \ executable('python3')? 'python3':
    \ executable('pyflakes')? 'pyflakes':
    \ 'python'
  let s:cmdopt = executable('pyflakes3')? '':
    \ executable('pyflakes')? 'pyflakes':
    \ executable('python3')? '-m pyflakes':
    \ executable('pyflakes')? '' :
    \ '-m pyflakes'
  let g:quickrun_config["watchdogs_checker/pyflakes3"] = {
    \ "command": s:pyflakes,
    \ "cmdopt" : s:cmdopt,
    \ "exec": "%c %o %s:p",
    \ "errorformat": '%f:%l:%m',
    \ }
  unlet s:pyflakes
  unlet s:cmdopt

  let g:quickrun_config["python/watchdogs_checker"] = {
    \ "type": "watchdogs_checker/pyflakes3",
    \ }
'''
# let g:quickrun_config['watchdogs_checker/_'] = {'outputter/quickfix/open_cmd': ''}
hook_post_source = '''
  call watchdogs#setup(g:quickrun_config)
'''
# }}} code check


# others {{{
[[plugins]]
repo = 'Shougo/neomru.vim'

[[plugins]]
repo = 'Shougo/unite.vim'

[[plugins]]
repo = 'kien/ctrlp.vim'

[[plugins]]
repo = 'fuenor/qfixhowm'
hook_add = '''
  let QFixHowm_key = 'g'
  let howm_dir = '~/Dropbox/memo/howm'
  let howm_filename      = '%Y/%m/%Y-%m-%d-%H%M%S.howm'
  let howm_fileencoding  = 'utf-8'
  let howm_fileformat    = 'unix'
  let QFixHowm_DiaryFile = 'diary/%Y/%m/%Y-%m-%d-000000.howm'
'''

# }}} others

